## プレゼン仕様書 — LLMのしくみと良いプロンプトの作り方（30分）

最終更新: 2025-09-21

---

### 概要
非エンジニア向けに、LLM（Transformer）の基本動作を直感的に理解し、その理解を使って「明確で再現性のある良いプロンプト」を自力で設計・改善できるようにする30分の短時間ワークショップ。

### 対象・前提
- AIツールは日常的に使うが、モデル内部の技術は未学習の非エンジニア。
- PC持参、最新ブラウザ利用可（Chrome/Edge/Safari/Firefox）。
- ローカルで `index.html` を開けること（ネット不調時のオフライン代替手段）。

### 時間
- 合計30分（質疑含む）。

### 学習目標（行動で表現）
- トークン化・注意機構・次トークン予測を、数式なしで人に説明できる。
- 役割・文脈・制約・出力形式の4要素を満たすプロンプトを作れる。
- 与えられた出力を簡易ルーブリックで採点し、改善点を特定できる。
- 「Transformerの動作」と「良いプロンプトの4要素」がどう結び付くかを説明できる。

### 成功指標（評価方法）
- 最終ワークのルーブリック採点で参加者“全員”が75点以上に到達。
- 退出時ミニアンケートで「理解できた/使えそう」計80%以上。

### 準備物・環境
- 配布物: 1枚チートシート（用語とテンプレ）、採点シート。
- 機材: 進行PC + プロジェクタ、参加者用PC、タイマー。
- 事前設定: `index.html` を各PCに配布／事前に開いておく。

---

## アジェンダ（00:00起点）
- 00:00–02:00 イントロ（目的・成功条件・操作チェック）
  - ミニ用語解説「プロンプトとは」：AIに渡す「指示や材料」をひとかたまりにした入力文。モデルはこの入力を手がかりに、続きを最もらしく補う。
- 02:00–06:00 ステップ1 トークン化（説明2m／体験2m）
- 06:00–11:00 ステップ2 注意機構（説明2.5m／体験2.5m）
- 11:00–16:00 ステップ3 次トークン予測（説明2.5m／体験2.5m）
- 16:00–17:00 ブリッジ：なぜ4要素が効くのか（要点整理・クイックデモ）
- 17:00–24:00 プロンプト設計（説明2.5m／個人ワーク4.5m）
- 24:00–28:00 リライト＆75点チェック（ペア30秒チェック含む）
- 28:00–30:00 まとめ・Next Actions・Q&A

---

## コンテンツ詳細（実施手順）

### イントロ（00:00–02:00）
- ねらい: ゴール・測定方法・操作方法を即共有して安心感を作る。
- アクション: 全員に `index.html` を開いてもらい、ボタンとスライダが動くか確認。
- 伝える要点: 「今日のキーワードは トークン／注意／次トークン予測。理解→体験→設計の順で進みます。」

### ステップ1 トークン化（02:00–06:00）
- ねらい: 文字列が離散的なかたまり（トークン）に分かれることを体感。
- デモ（進行役）: `index.html` のトークン化表示を見せ、同じ文でも分かれ方があることを示す。
- 参加ワーク: 手元で短文を入力→トークン分割を観察→「固有名詞・数値・記号」の扱いをメモ。
- メッセージ: 「プロンプトは“単語”ではなく“トークン列”。曖昧語や造語は分割が不安定になりがち。」

### ステップ2 注意機構（06:00–11:00）
- ねらい: 予測時に、文脈中のどこに“注意”が向くかを視覚的に理解。
- デモ: 単語をクリック→関連語がハイライトされる様子を共有。
- 参加ワーク: 2つの文を比べ、主語・対象・否定語の位置を変えてハイライトの違いを観察。
- メッセージ: 「重要語は“近い/明確/一貫”に。冗長・矛盾は注意が散る。」

### ステップ3 次トークン予測（11:00–16:00）
- ねらい: モデルは“次の1トークン”の確率分布を更新し続けるだけ、を直感で掴む。
- デモ: 候補トークンと確率を表示。Temperatureを動かし、出力の決まりやすさ/多様性の変化を確認。
- 参加ワーク: 同一プロンプトで温度0.0/0.7を比較し、「再現性」と「発想」のトレードオフを言語化。
- メッセージ: 「重要タスク=低温で安定／ブレスト=中温で多様。」

### Transformer原理から導くプロンプト設計（16:00–17:00）
- 目的
  - Transformerの原理（トークン化／注意／次トークン予測）を「分布を望ましい方向に偏らせるレバー」に結びつけ、次セクションの実践テンプレ（C案）へスムーズに橋渡しする。
  - 一言メッセージ: プロンプト設計＝確率分布の設計。役割・文脈・手順・出力形式で再現性を上げる。

- 原理→レバー（対応マップ）
  - トークン化 → 文脈・例
    - 曖昧語や造語の分割揺れを抑えるため、定義語・固有名詞・数値・単位を「文脈」に明記。代表表記は「例」で固定。
  - 注意機構 → 役割＋区切り（見出し/タグ）
    - 役割宣言で重要語へ注意集中。見出しやタグで情報を分け、関連語を近接配置。
  - 次トークン予測 → 手順・ルール／出力形式／温度
    - 手順の明示で推論順序を固定、制約で候補集合を縮小、出力形式で構造を固定。重要タスクは低温（0付近）。
  - 会話の最終上書き → 重要ポイントの再確認
    - 直近の指示が強く効くため、終盤にFinal Remindersを短く置く。
  - 出力の安定化 → Prefilled response
    - JSONスケルトン等の枠を先に提示して鍵・順序を固定。

- 良いプロンプトを書く5つのコツ

1) 目的（成功条件）を一文で先頭に置く
- NG: 「文章書いて」
- OK: 「新商品発表のプレスリリースを300字で。対象はITメディア。締めにCTAを1文。」
- ポイント: Doneの定義を明文化すると、次トークン分布が絞られ再現性が上がる。

2) 役割＋トーンで視点を固定する
- 例: 「あなたは広報担当。丁寧体で、断定口調は避ける。」
- ポイント: 役割宣言と語調は注意を集約し、解釈のブレを減らす。

3) 文脈と参照は“区切って”渡す
- 例: 「`<context>{製品概要…}</context><audience>{読者像…}</audience>`」
- NG: 背景・制約・対象が一段落に混在
- ポイント: 見出し/タグ/区切りで関連トークンを近接配置し、注意を誘導。

4) 手順・ルールは番号付き＋検証一文
- 例: 「1) 事実の抽出 → 2) 要約作成 → 3) 禁止: 新情報の捏造。最後に“事実と矛盾がないか”を自己チェック。」
- ポイント: 手順の明示は推論の順序を固定し、生成の安定性を高める。

5) 出力形式は厳密指定＋ミニ例
- 指定: 「JSONで。keys: title, body, cta」
- 例:
```json
{
  "title": "○○発表",
  "body": "…",
  "cta": "詳細はこちら"
}
```
- ポイント: 構造を固定すると後段処理（評価・抽出）が容易になる。

- C案：6コア＋4オプション（持ち帰りチートシート）
  - コア6（必須）
    1) 役割＋トーン（Role/Tone）: モデルの視点・語調を固定
    2) 目的（Task/Success）: 成功条件を一文で明記
    3) 文脈（Background）: 参照文書・画像・対象・前提・制約
    4) 手順・ルール（Instructions & Rules）: 実行順序・禁止事項を番号付きで
    5) 出力形式（Output Formatting）: JSON/表/タグなど厳密指定
    6) 例（Examples: Few-shot）: 1–2件の入出力例
  - オプション4（必要に応じて）
    7) 会話履歴（Conversation History）
    8) 思考方針（Reasoning Directive: step-by-step/検証）
    9) 重要ポイントの再確認（Final Reminders）
    10) Prefilled Response（定型のスケルトン）
  - 使い方: まずコア6を埋め、必要に応じてオプションを追加。区切り（見出し/タグ）で構造を明示し、並び順と近接で注意を誘導。

- ミニデモ（30秒）
  - ベース: 役割・出力形式なし（seed固定、温度0.7）
  - 介入A: 役割＋トーンを追加→語調と要点の一貫性が向上
  - 介入B: 出力形式（JSON）＋手順1行を追加→候補分布が狭まり、JSON整形率が上がる
  - 見るポイント: Top-1/Top-3確率、JSON整形率、要点の一貫性（注意ヒートマップがあれば集中度）

- よくある落とし穴 → 対処
  - 背景を一段落に詰め込む → 見出し/タグで区切る（context/audience/constraints）
  - ゴール不明瞭 → 目的（成功条件）を先頭の一文で固定
  - ルールが散在 → 手順・禁止事項を番号付きで
  - 出力がブレる → 出力形式＋Prefilledで鍵と順序を固定
  - 例が過多/不足 → Few-shotは1–2件に限定し「境界」を示す

- 次セクションへのつなぎ
  - 「今の“レバー”をC案テンプレに落とし込み、17:00–24:00で各自の課題に適用→出力を採点します。」

- 話す台本（約20秒）
  - 「モデルは次トークンの確率分布で動きます。役割・文脈・手順・出力形式を入れるほど、分布が狭まり再現性が上がります。いまのように役割とJSON指定を足すだけで、上位確率が偏り、注意が必要語に集中します。」

### プロンプト設計（17:00–24:00）
- ねらい: 4要素（役割・文脈・制約・出力形式）を満たすプロンプトを作る。
- フレーム: 次のテンプレを配布し、その場で埋める。

```text
[コア]
役割・トーン: {例: 旅行プランナーとして。丁寧体}
目的（成功条件）: {一文で。Doneの定義}
文脈（背景/参照）: {対象/読み手/利用場面/入力データ/制約}
手順・ルール: 1) {まず…} 2) {次に…} 3) {禁止事項…}
出力形式: {JSON/表/見出し/言語/順序/長さ}
例（Few-shot）:
  入力: {…}
  期待出力: {…}

[オプション]
会話履歴: {直近のやり取り要約/引用}
思考方針: {検証手順/境界条件/反例チェック}
重要ポイントの再確認: {最後に守るルールを箇条書き}
Prefilled response（あれば）: <response>{ここに本文}</response>
```

- 個人ワーク: 自分の業務に即した課題で上記を埋め、1回実行→出力を採点。

### リライト＆75点チェック（24:00–28:00）
- ねらい: 採点→改善の反復を体験し、再現性のある手順に落とす。
- 手順:（1）隣同士でプロンプトを30秒で読み合い、ルーブリックで採点（相互採点OK）。（2）不足点を1つだけ直して再実行。（3）75点到達を確認。

### まとめ・Q&A（28:00–30:00）
- ねらい: 振り返りと次アクションの明確化。
- 要点: 「理解（トークン/注意/予測）→設計（4要素）→評価（ルーブリック）」の循環。
- Next Actions: テンプレで3案件を書き出す／“低温運用”を試す／社内共有を1回。

---

## プロンプト品質チェックリスト（配布用）
- 役割: 専門性・視点が明記されている（例: “法務担当者として”）。
- 目的: タスクの成功条件が明文化されている（Doneの定義）。
- 文脈: 読み手/制約/利用場面/入力が具体的。
- 制約: 禁止事項・品質・語調・長さ・引用の有無がある。
- 出力形式: 見出し/表/JSON/箇条書きなど構造化され再現性がある。
- 検証: チェック項目や評価基準が添えられている。

## ルーブリック（100点満点）
- 明確な目的 15点
- 十分な文脈 15点
- 適切な役割指定 10点
- 具体的な制約 15点
- 出力形式の明示 15点
- 例示（入出力サンプル・境界条件）10点
- 推論支援（思考手順/分割/検証）10点
- トーン/ガードレール 10点
→ 合格ライン: 75点。

---

## ファシリテーション・メモ
- タイムキープ: 各セクション終了1分前に合図。
- 全員参加: 体験パートは“全員の手”を必須に。
- 語り口: 比喩を使い、専門用語は言い換え→用語集を指差し。
- トラブル時: `index.html` はローカルで開く想定。ネット不要。

## リスクと代替案
- 時間超過: ステップ2の個人ワークを30秒短縮、Q&Aを1分に圧縮。
- 技術トラブル: スクリーン共有不可→口頭+手元操作のみで進行。資料はチートシートを中心に。
- 参加者スキル差: ハイレベル質問は最後に回す“パーキングロット”運用。

## 用語の超簡易辞書
- トークン: 文章を機械が扱う最小単位のかたまり。
- 注意（Attention）: 予測に効く場所へ重みづけして見る仕組み。
- 次トークン予測: 次に来る1トークンの確率を更新して選ぶこと。
- Temperature: 出力のバラつきを調整するつまみ（低=堅実／中=多様）。

## 配布物（1枚）
- 表面: 4要素テンプレ＋ルーブリック。
- 裏面: 用語集＋よくある失敗例（曖昧語/過剰指示/矛盾）。

## 実装メモ（開発者向け）：インタラクティブHTMLでのTransformer近似の注意点

- 前提: HTML/CSS/JavaScriptのみ、ローカル実行（外部サーバなし）。学習や巨大語彙の再現は目的外。理解の体感を優先し、厳密一致は求めないが“同じ入力→同じ振る舞い”の再現性は確保する。

- トークン化
  - 方式: BPE系（例: tiktoken風のBPEマージ表）またはUnigram（SentencePiece風）を簡略化して実装。辞書は小規模JSONで同梱。
  - 一貫性: Unicode正規化（NFKC）と空白・改行・記号の扱いを固定。未知片は文字単位フォールバックで可視性維持。
  - 同期: 注意可視化・予測パートと同じ分割器を必ず共有（別実装にしない）。

- 位置情報（Positional Encoding）
  - 実装: 可視化重視なら正弦波を採用。注記として、多くの近年LLMはRoPE（Rotary Position Embedding）やALiBi等を用いる旨を明記。

- 注意機構（Self-Attention）
  - スケーリング: スコアは `softmax((QK^T)/sqrt(d_k))`。温度Tはsoftmax前にlogitを`/T`。
  - 数値安定化: `softmax(x - max(x))` を用いる。
  - デモ用パラメータ: `d_k=16~32`、ヘッド1–2、系列長は最大64–128（O(n^2)可視化のため）。
  - 並行性: 計算はWeb Workerで行い、UIはメインスレッドで描画。アニメーションは `requestAnimationFrame`。
  - 可視化: カラーマップは色覚多様性に配慮（例: viridis/cividis）。

- 次トークン予測
  - 近似: 本物の重みは使用せず、簡易n-gram/条件付き確率テーブル（小規模JSON）で模擬。`temperature`、`top-k`、`top-p`（nucleus）に対応。
  - 用語の定義: `top-k`は確率上位k候補からサンプリング、`top-p`は累積確率がp以上となる最小集合からサンプリング。
  - 再現性: `seed` 入力を用意し、温度0は `argmax` 固定。乱数はseed可能なPRNG（例: seedrandom系、またはMulberry32等の自前実装）を使用。

- パフォーマンス
  - データ構造: `Float32Array` などTypedArrayを使用。大配列の再割当て回避。
  - 描画: 高頻度描画は `requestAnimationFrame`。重い描画は `OffscreenCanvas` + Workerへ委譲も検討。
  - 制限: 入力トークン数/語彙/ヘッド/層数の上限をUIに表示（例: L≤128, V≤1k, heads≤2, layers=1）。

- セキュリティ/プライバシー
  - 入力のHTMLエスケープ、DOM操作は`textContent`を基本に。外部リクエストなし、埋め込みアセットのみ。
  - PII入力に関する注意文をUIに表示。データは保存しない旨を明記。

- UI/UX・アクセシビリティ
  - コントロール: 温度/`top-k`/seed/リセットを常設。数値はツールチップで説明。
  - キーボード操作・`aria-*` 属性・コントラスト比を確保。

- 妥協点（明示する免責）
  - 層の積層・FFN・正確な語彙/学習は省略し、原理図としての近似であることをヘルプに明記（実サービスは最適化版注意やRoPE等を採用）。

---

## 参考: 進行用スクリプト（冒頭30秒）
「今日は“トークン・注意・次トークン予測”を直感で掴み、テンプレで“良いプロンプト”を作れるようになります。最後に採点して75点を目指します。ではまず `index.html` を開いて、ボタンとスライダが動くか確認してください。」

## 参考：良いプロンプト by Google

- 出典: [Prompt engineering: overview and guide](https://www.promptingguide.ai/)

Strategies for writing better prompts
1. Set Clear Goals and Objectives
2. Provide Context and Background Information
3. Use Few-Shot Prompting
4. Be Specific
5. Iterate and Experiment
6. Leverage Chain of Thought Prompting

## 参考：プロンプト構造 by Anthropic

- 出典: [プロンプティング101 | コード w/ Claude](https://www.youtube.com/watch?v=ysPbXH0LpIE)

### エグゼクティブサマリー
構造化されたプロンプト（タスク→動的コンテンツ→手順→事例→重要点の再確認）が、特にAPI経由のタスクで一貫した高品質出力をもたらす。プロンプトエンジニアリングは、明確な指示と十分な文脈を与え、反復的に改善する実践である。

### ベストプラクティス
1. 明確なプロンプト構造: タスクの説明→動的コンテンツ→詳細手順→事例→重要点の再確認。
2. システムプロンプトの活用: クエリ間で不変の背景情報をシステム側に保持。
3. 構造化と区切り文字: 情報をXML等で区切ると参照しやすくなる。
4. 段階的な推論指示: 処理順序を明示して人間の手順を模倣させる。
5. 出力フォーマット指定: 最終出力を特定タグで囲み、後段処理を容易化。
6. 高度テクニック: Few-shot、事前入力応答、拡張思考の併用。

### ケーススタディ：スウェーデンの自動車保険金請求
- 目的: 事故報告フォーム＋手描きスケッチから状況理解と過失判定。
- モデル: Claude 3 Opus（温度0で決定論運用）。

#### 初期試行（失敗例）
- 結果: 「スキー事故」と誤解。
- 原因: 自動車事故という文脈不足。曖昧さにより誤推論。

### 推奨されるプロンプト構造と反復改善

### 構成要素
1. Task context
2. Tone context
3. Background data, documents, and images
4. Detailed task description & rules
5. Examples
6. Conversation history
7. Immediate task description or request
8. Thinking step by step / take a deep breath
9. Output formatting
10. Prefilled response (if any)

#### 段階的改善（V2→最終）
- ステップ1（V2）: 文脈とトーンを追加。「自信がない場合は評価しない」等の方針を明示。
- ステップ2（V3）: システムプロンプトで静的情報を定義し、XMLで区切る（例: `<user_preferences>`）。結果としてフォーム理解が安定。
- ステップ3: 手順の順序を指示。「まずフォーム→次にスケッチ」。思考過程を明示的に出力。
- ステップ4: 出力形式と最終リマインダーを追加。評決を `<final_verdict>` で囲み、後段抽出を容易に。

### その他の重要テクニック

| 技術 | 説明 | ユースケース |
| --- | --- | --- |
| 事例（Few-shot） | システム側に複数の入出力例（画像はBase64でも可）を保持 | 曖昧・複雑ケースで挙動を望ましい方向に誘導 |
| 会話履歴 | 過去やり取りをプロンプトに含め文脈を強化 | 対話継続型のユーザー向けアプリ |
| 事前入力応答（Pre-filled） | 応答の冒頭や必須要素を固定（例: `<final_verdict>`） | 厳密なJSON等の構造化出力を強制したい場合 |
| 拡張思考（Extended Thinking） | 思考時間を与え、`<thinking>` 内にスクラッチパッドを出力 | 推論の観察とシステムプロンプト改善の洞察取得 |
